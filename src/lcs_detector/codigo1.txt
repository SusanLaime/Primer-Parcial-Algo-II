import random
import datetime
import os
import json

# --- Configuración y Constantes ---
# Nombre del archivo para guardar los datos de la biblioteca
BIBLIOTECA_DATA_FILE = "biblioteca_data.json"
MIN_LIBROS_GENERAR = 500  # Para asegurar que la generación cumpla con el requisito de líneas
MAX_LIBROS_GENERAR = 1000 # Límite superior para la generación aleatoria

# --- Clases Base ---
class Entidad:
    """Clase base para entidades con un ID único."""
    _next_id = 1

    def __init__(self):
        self.id = Entidad._next_id
        Entidad._next_id += 1

    def __repr__(self):
        return f"ID: {self.id}"

    def to_dict(self):
        return {"id": self.id}

    @classmethod
    def from_dict(cls, data):
        obj = cls()
        obj.id = data["id"]
        # Ajustar _next_id si es necesario al cargar
        if obj.id >= Entidad._next_id:
            Entidad._next_id = obj.id + 1
        return obj

class Persona(Entidad):
    """Clase base para personas (autores, usuarios)."""
    def __init__(self, nombre, apellido):
        super().__init__()
        self.nombre = nombre
        self.apellido = apellido

    def __str__(self):
        return f"{self.nombre} {self.apellido}"

    def to_dict(self):
        data = super().to_dict()
        data.update({"nombre": self.nombre, "apellido": self.apellido})
        return data

    @classmethod
    def from_dict(cls, data):
        obj = cls(data["nombre"], data["apellido"])
        obj.id = data["id"]
        if obj.id >= Entidad._next_id:
            Entidad._next_id = obj.id + 1
        return obj

# --- Clases Específicas ---
class Autor(Persona):
    """Representa a un autor de libros."""
    def __init__(self, nombre, apellido, nacionalidad="Desconocida"):
        super().__init__(nombre, apellido)
        self.nacionalidad = nacionalidad
        self.libros_escritos_ids = [] # IDs de libros escritos por este autor

    def __str__(self):
        return f"Autor: {self.nombre} {self.apellido} ({self.nacionalidad})"

    def to_dict(self):
        data = super().to_dict()
        data.update({"nacionalidad": self.nacionalidad, "libros_escritos_ids": self.libros_escritos_ids})
        return data

    @classmethod
    def from_dict(cls, data):
        obj = cls(data["nombre"], data["apellido"], data.get("nacionalidad", "Desconocida"))
        obj.id = data["id"]
        obj.libros_escritos_ids = data.get("libros_escritos_ids", [])
        if obj.id >= Entidad._next_id:
            Entidad._next_id = obj.id + 1
        return obj

class Usuario(Persona):
    """Representa a un usuario de la biblioteca."""
    def __init__(self, nombre, apellido, email):
        super().__init__(nombre, apellido)
        self.email = email
        self.libros_prestados_ids = [] # IDs de libros actualmente prestados

    def __str__(self):
        return f"Usuario: {self.nombre} {self.apellido} ({self.email})"

    def to_dict(self):
        data = super().to_dict()
        data.update({"email": self.email, "libros_prestados_ids": self.libros_prestados_ids})
        return data

    @classmethod
    def from_dict(cls, data):
        obj = cls(data["nombre"], data["apellido"], data["email"])
        obj.id = data["id"]
        obj.libros_prestados_ids = data.get("libros_prestados_ids", [])
        if obj.id >= Entidad._next_id:
            Entidad._next_id = obj.id + 1
        return obj

class Libro(Entidad):
    """Representa un libro en la biblioteca."""
    def __init__(self, titulo, anio_publicacion, autor_id, isbn, cantidad_total=1):
        super().__init__()
        self.titulo = titulo
        self.anio_publicacion = anio_publicacion
        self.autor_id = autor_id # ID del autor
        self.isbn = isbn
        self.cantidad_total = cantidad_total
        self.cantidad_disponible = cantidad_total
        self.prestamos_activos = {} # {usuario_id: fecha_prestamo}

    def __str__(self):
        return f"Libro: '{self.titulo}' ({self.anio_publicacion}) - ISBN: {self.isbn}"

    def to_dict(self):
        data = super().to_dict()
        data.update({
            "titulo": self.titulo,
            "anio_publicacion": self.anio_publicacion,
            "autor_id": self.autor_id,
            "isbn": self.isbn,
            "cantidad_total": self.cantidad_total,
            "cantidad_disponible": self.cantidad_disponible,
            "prestamos_activos": {str(k): v.isoformat() if isinstance(v, datetime.date) else v for k, v in self.prestamos_activos.items()}
        })
        return data

    @classmethod
    def from_dict(cls, data):
        obj = cls(data["titulo"], data["anio_publicacion"], data["autor_id"], data["isbn"], data["cantidad_total"])
        obj.id = data["id"]
        obj.cantidad_disponible = data["cantidad_disponible"]
        # Convertir fechas de string a datetime.date
        obj.prestamos_activos = {int(k): datetime.date.fromisoformat(v) for k, v in data.get("prestamos_activos", {}).items()}
        if obj.id >= Entidad._next_id:
            Entidad._next_id = obj.id + 1
        return obj

class Biblioteca:
    """Gestiona todos los libros, autores y usuarios."""
    def __init__(self):
        self.libros = {}    # {id_libro: objeto_libro}
        self.autores = {}   # {id_autor: objeto_autor}
        self.usuarios = {}  # {id_usuario: objeto_usuario}
        self.cargar_datos() # Cargar datos al iniciar

    def guardar_datos(self):
        """Guarda el estado actual de la biblioteca en un archivo JSON."""
        data = {
            "autores": {a_id: autor.to_dict() for a_id, autor in self.autores.items()},
            "usuarios": {u_id: usuario.to_dict() for u_id, usuario in self.usuarios.items()},
            "libros": {l_id: libro.to_dict() for l_id, libro in self.libros.items()},
            "_next_id_entidad": Entidad._next_id # Guardar el próximo ID disponible
        }
        try:
            with open(BIBLIOTECA_DATA_FILE, 'w') as f:
                json.dump(data, f, indent=4)
            print(f"Datos guardados en {BIBLIOTECA_DATA_FILE}")
        except IOError as e:
            print(f"Error al guardar datos: {e}")

    def cargar_datos(self):
        """Carga el estado de la biblioteca desde un archivo JSON."""
        if not os.path.exists(BIBLIOTECA_DATA_FILE):
            print("No se encontró archivo de datos. Iniciando con biblioteca vacía.")
            return

        try:
            with open(BIBLIOTECA_DATA_FILE, 'r') as f:
                data = json.load(f)

            # Restablecer el contador de IDs antes de cargar para evitar conflictos
            Entidad._next_id = 1

            # Cargar autores
            for autor_data in data.get("autores", {}).values():
                autor = Autor.from_dict(autor_data)
                self.autores[autor.id] = autor

            # Cargar usuarios
            for usuario_data in data.get("usuarios", {}).values():
                usuario = Usuario.from_dict(usuario_data)
                self.usuarios[usuario.id] = usuario

            # Cargar libros
            for libro_data in data.get("libros", {}).values():
                libro = Libro.from_dict(libro_data)
                self.libros[libro.id] = libro
            
            # Restaurar _next_id_entidad al valor guardado
            Entidad._next_id = data.get("_next_id_entidad", Entidad._next_id)

            print(f"Datos cargados desde {BIBLIOTECA_DATA_FILE}")

        except (IOError, json.JSONDecodeError) as e:
            print(f"Error al cargar datos desde {BIBLIOTECA_DATA_FILE}: {e}")
            print("Iniciando con biblioteca vacía.")
            self.libros.clear()
            self.autores.clear()
            self.usuarios.clear()
            Entidad._next_id = 1 # Asegurarse de resetear el contador si falla la carga

    # --- Métodos de Gestión ---
    def agregar_autor(self, nombre, apellido, nacionalidad="Desconocida"):
        """Agrega un nuevo autor a la biblioteca."""
        autor = Autor(nombre, apellido, nacionalidad)
        self.autores[autor.id] = autor
        print(f"Autor '{autor}' agregado. ID: {autor.id}")
        return autor

    def agregar_usuario(self, nombre, apellido, email):
        """Agrega un nuevo usuario a la biblioteca."""
        usuario = Usuario(nombre, apellido, email)
        self.usuarios[usuario.id] = usuario
        print(f"Usuario '{usuario}' agregado. ID: {usuario.id}")
        return usuario

    def agregar_libro(self, titulo, anio_publicacion, autor_id, isbn, cantidad_total=1):
        """Agrega un nuevo libro a la biblioteca."""
        if autor_id not in self.autores:
            print(f"Error: Autor con ID {autor_id} no encontrado.")
            return None
        libro = Libro(titulo, anio_publicacion, autor_id, isbn, cantidad_total)
        self.libros[libro.id] = libro
        self.autores[autor_id].libros_escritos_ids.append(libro.id)
        print(f"Libro '{libro}' agregado. ID: {libro.id}")
        return libro

    def buscar_libro(self, query, por="titulo"):
        """Busca libros por título o ISBN."""
        resultados = []
        for libro in self.libros.values():
            if por == "titulo" and query.lower() in libro.titulo.lower():
                resultados.append(libro)
            elif por == "isbn" and query == libro.isbn:
                resultados.append(libro)
        return resultados

    def buscar_autor(self, query, por="nombre"):
        """Busca autores por nombre o apellido."""
        resultados = []
        for autor in self.autores.values():
            if por == "nombre" and query.lower() in autor.nombre.lower():
                resultados.append(autor)
            elif por == "apellido" and query.lower() in autor.apellido.lower():
                resultados.append(autor)
            elif por == "nombre_completo" and query.lower() in str(autor).lower():
                resultados.append(autor)
        return resultados

    def prestar_libro(self, libro_id, usuario_id):
        """Presta un libro a un usuario."""
        libro = self.libros.get(libro_id)
        usuario = self.usuarios.get(usuario_id)

        if not libro:
            print(f"Error: Libro con ID {libro_id} no encontrado.")
            return False
        if not usuario:
            print(f"Error: Usuario con ID {usuario_id} no encontrado.")
            return False

        if libro.cantidad_disponible > 0:
            libro.cantidad_disponible -= 1
            libro.prestamos_activos[usuario_id] = datetime.date.today()
            usuario.libros_prestados_ids.append(libro_id)
            print(f"Libro '{libro.titulo}' prestado a '{usuario.nombre}'.")
            return True
        else:
            print(f"Error: No hay copias disponibles de '{libro.titulo}'.")
            return False

    def devolver_libro(self, libro_id, usuario_id):
        """Devuelve un libro de un usuario."""
        libro = self.libros.get(libro_id)
        usuario = self.usuarios.get(usuario_id)

        if not libro:
            print(f"Error: Libro con ID {libro_id} no encontrado.")
            return False
        if not usuario:
            print(f"Error: Usuario con ID {usuario_id} no encontrado.")
            return False

        if usuario_id in libro.prestamos_activos and libro_id in usuario.libros_prestados_ids:
            libro.cantidad_disponible += 1
            del libro.prestamos_activos[usuario_id]
            usuario.libros_prestados_ids.remove(libro_id)
            print(f"Libro '{libro.titulo}' devuelto por '{usuario.nombre}'.")
            return True
        else:
            print(f"Error: El libro {libro.titulo} no fue prestado a {usuario.nombre}.")
            return False

    def obtener_libros_prestados_por_usuario(self, usuario_id):
        """Obtiene la lista de libros prestados a un usuario."""
        usuario = self.usuarios.get(usuario_id)
        if not usuario:
            print(f"Error: Usuario con ID {usuario_id} no encontrado.")
            return []
        
        prestados = []
        for libro_id in usuario.libros_prestados_ids:
            libro = self.libros.get(libro_id)
            if libro:
                prestados.append(libro)
        return prestados

    def _generar_isbn(self):
        """Genera un ISBN aleatorio y único."""
        while True:
            isbn = "".join([str(random.randint(0, 9)) for _ in range(13)])
            # Verificar si ya existe
            if not any(l.isbn == isbn for l in self.libros.values()):
                return isbn

    def generar_datos_aleatorios(self, num_autores=20, num_usuarios=30, num_libros_min=MIN_LIBROS_GENERAR, num_libros_max=MAX_LIBROS_GENERAR):
        """Genera datos aleatorios para poblar la biblioteca."""
        print("\nGenerando datos aleatorios...")
        nombres = ["Juan", "Maria", "Carlos", "Ana", "Pedro", "Sofia", "Luis", "Elena"]
        apellidos = ["García", "Rodríguez", "Martínez", "López", "González", "Pérez", "Sánchez", "Ramírez"]
        nacionalidades = ["Mexicana", "Española", "Argentina", "Colombiana", "Chilena", "Peruana", "Ecuatoriana", "Boliviana"]
        titulos_base = ["Historia de", "Aventuras de", "El misterio de", "Crónicas de", "La vida de", "El arte de", "Viaje a"]
        sustantivos = ["dragones", "galaxias", "tiempos", "civilizaciones", "la mente", "la naturaleza", "el futuro", "el pasado"]
        
        # Generar autores
        for _ in range(num_autores):
            nombre = random.choice(nombres)
            apellido = random.choice(apellidos)
            nacionalidad = random.choice(nacionalidades)
            self.agregar_autor(nombre, apellido, nacionalidad)
        print(f"Se generaron {len(self.autores)} autores.")

        # Generar usuarios
        for i in range(num_usuarios):
            nombre = random.choice(nombres)
            apellido = random.choice(apellidos)
            email = f"{nombre.lower()}.{apellido.lower()}{i}@example.com"
            self.agregar_usuario(nombre, apellido, email)
        print(f"Se generaron {len(self.usuarios)} usuarios.")

        # Generar libros (asegurando el mínimo de líneas)
        num_libros = random.randint(num_libros_min, num_libros_max)
        autores_ids = list(self.autores.keys())
        if not autores_ids:
            print("No hay autores para generar libros.")
            return

        for i in range(num_libros):
            titulo = f"{random.choice(titulos_base)} {random.choice(sustantivos)} {i+1}"
            anio = random.randint(1950, datetime.date.today().year)
            autor_id = random.choice(autores_ids)
            isbn = self._generar_isbn()
            cantidad = random.randint(1, 5) # Cantidad de copias
            self.agregar_libro(titulo, anio, autor_id, isbn, cantidad)
        print(f"Se generaron {len(self.libros)} libros.")
        self.guardar_datos() # Guardar después de generar

    def mostrar_estadisticas(self):
        """Muestra estadísticas básicas de la biblioteca."""
        print("\n--- Estadísticas de la Biblioteca ---")
        print(f"Total de Libros: {len(self.libros)}")
        print(f"Total de Autores: {len(self.autores)}")
        print(f"Total de Usuarios: {len(self.usuarios)}")
        
        libros_prestados_count = 0
        for libro in self.libros.values():
            libros_prestados_count += len(libro.prestamos_activos)
        print(f"Total de Copias Prestadas: {libros_prestados_count}")

        # Libros más prestados (ejemplo)
        prestamos_por_libro = {}
        for libro in self.libros.values():
            if libro.id in prestamos_por_libro: # Esto es un fix si hubo un bug en la carga que duplicaba IDs
                pass
            else:
                prestamos_por_libro[libro.id] = libro.cantidad_total - libro.cantidad_disponible # Cantidad de prestamos *activos*
        
        # Ordenar libros por la cantidad de prestamos activos
        libros_ordenados = sorted(prestamos_por_libro.items(), key=lambda item: item[1], reverse=True)
        print("\nTop 5 Libros Más Prestados (copias activas):")
        for i, (libro_id, num_prestamos) in enumerate(libros_ordenados[:5]):
            if num_prestamos > 0:
                libro = self.libros.get(libro_id)
                if libro:
                    print(f"  {i+1}. '{libro.titulo}' ({num_prestamos} copias prestadas)")
            else:
                print("  No hay libros con préstamos activos para mostrar.")
                break # Salir si no hay más préstamos

    def _menu_principal(self):
        """Muestra el menú principal de la aplicación."""
        print("\n--- Sistema de Gestión de Biblioteca ---")
        print("1. Agregar Autor")
        print("2. Agregar Usuario")
        print("3. Agregar Libro")
        print("4. Prestar Libro")
        print("5. Devolver Libro")
        print("6. Buscar Libro")
        print("7. Buscar Autor")
        print("8. Ver Libros Prestados por Usuario")
        print("9. Mostrar Estadísticas")
        print("10. Generar Datos Aleatorios (Si la biblioteca está vacía o quieres más)")
        print("0. Salir")

    def ejecutar(self):
        """Punto de entrada principal de la aplicación."""
        while True:
            self._menu_principal()
            opcion = input("Seleccione una opción: ")

            if opcion == "1":
                nombre = input("Nombre del autor: ")
                apellido = input("Apellido del autor: ")
                nacionalidad = input("Nacionalidad (opcional): ")
                self.agregar_autor(nombre, apellido, nacionalidad if nacionalidad else "Desconocida")
            elif opcion == "2":
                nombre = input("Nombre del usuario: ")
                apellido = input("Apellido del usuario: ")
                email = input("Email del usuario: ")
                self.agregar_usuario(nombre, apellido, email)
            elif opcion == "3":
                titulo = input("Título del libro: ")
                anio = int(input("Año de publicación: "))
                autor_id = int(input("ID del autor: "))
                isbn = input("ISBN: ")
                cantidad = int(input("Cantidad de copias: "))
                self.agregar_libro(titulo, anio, autor_id, isbn, cantidad)
            elif opcion == "4":
                libro_id = int(input("ID del libro a prestar: "))
                usuario_id = int(input("ID del usuario: "))
                self.prestar_libro(libro_id, usuario_id)
            elif opcion == "5":
                libro_id = int(input("ID del libro a devolver: "))
                usuario_id = int(input("ID del usuario que devuelve: "))
                self.devolver_libro(libro_id, usuario_id)
            elif opcion == "6":
                query = input("Buscar libro por (titulo/isbn): ").lower()
                if query not in ["titulo", "isbn"]:
                    print("Opción inválida. Use 'titulo' o 'isbn'.")
                    continue
                valor = input(f"Ingrese el {query}: ")
                resultados = self.buscar_libro(valor, query)
                if resultados:
                    print("\n--- Resultados de la Búsqueda de Libros ---")
                    for libro in resultados:
                        autor = self.autores.get(libro.autor_id)
                        autor_nombre = str(autor) if autor else "Desconocido"
                        print(f"  ID: {libro.id}, Título: '{libro.titulo}', Año: {libro.anio_publicacion}, Autor: {autor_nombre}, ISBN: {libro.isbn}, Disponible: {libro.cantidad_disponible}/{libro.cantidad_total}")
                else:
                    print("No se encontraron libros.")
            elif opcion == "7":
                query = input("Buscar autor por (nombre/apellido/nombre_completo): ").lower()
                if query not in ["nombre", "apellido", "nombre_completo"]:
                    print("Opción inválida. Use 'nombre', 'apellido' o 'nombre_completo'.")
                    continue
                valor = input(f"Ingrese el {query}: ")
                resultados = self.buscar_autor(valor, query)
                if resultados:
                    print("\n--- Resultados de la Búsqueda de Autores ---")
                    for autor in resultados:
                        print(f"  ID: {autor.id}, {autor}")
                else:
                    print("No se encontraron autores.")
            elif opcion == "8":
                usuario_id = int(input("Ingrese el ID del usuario: "))
                libros_prestados = self.obtener_libros_prestados_por_usuario(usuario_id)
                if libros_prestados:
                    print(f"\n--- Libros prestados al usuario ID {usuario_id} ---")
                    for libro in libros_prestados:
                        print(f"  - '{libro.titulo}' (ID: {libro.id}, ISBN: {libro.isbn})")
                else:
                    print(f"El usuario ID {usuario_id} no tiene libros prestados o no existe.")
            elif opcion == "9":
                self.mostrar_estadisticas()
            elif opcion == "10":
                self.generar_datos_aleatorios()
            elif opcion == "0":
                self.guardar_datos() # Guardar antes de salir
                print("Saliendo del sistema. ¡Adiós!")
                break
            else:
                print("Opción inválida. Por favor, intente de nuevo.")
            
            # Guardar datos después de cada operación significativa (o al final)
            self.guardar_datos()

# --- Ejecución Principal ---
if __name__ == "__main__":
    biblioteca = Biblioteca()
    # Si la biblioteca está vacía al inicio, sugerir generar datos
    if not biblioteca.libros and not biblioteca.autores and not biblioteca.usuarios:
        print("\nLa biblioteca está vacía. Considera usar la opción '10' para generar algunos datos aleatorios.")
    biblioteca.ejecutar()